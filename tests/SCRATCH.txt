		// test("LCP", async ({ page }) => {
		// 	// evaluate the largest contentful paint
		// 	const largestContentfulPaint = await page.evaluate(() => {
		// 		return new Promise((resolve) => {
		// 			new PerformanceObserver((l) => {
		// 				const entries = l.getEntries()
		// 				// the last entry is the largest contentful paint
		// 				const largestPaintEntry = entries.at(-1)
		// 				// @ts-ignore
		// 				resolve(largestPaintEntry.startTime)
		// 			}).observe({
		// 				type: "largest-contentful-paint",
		// 				buffered: true,
		// 			})
		// 		})
		// 	})

		// 	console.log(`Largest Contentful Paint is: ${parseFloat(largestContentfulPaint)}ms`)

		// 	await expect(page).toHaveTitle(/Publishing Project/)
		// })

		// Navigate to the page before each test



const pw = require('playwright-core');

(async () => {
  const browser = await pw.chromium.connect({
    wsEndpoint: 'wss://cloud.testingbot.com/playwright?key=api_key&secret=api_secret&browserName=chrome&browserVersion=latest',
  })
  const context = await browser.newContext()
  const page = await context.newPage()

  await page.goto('https://testingbot.com/');
  const navigationTimingJson = await page.evaluate(() =>
    JSON.stringify(performance.getEntriesByType('navigation'))
  )
  const navigationTiming = JSON.parse(navigationTimingJson)

  if (navigationTiming.domComplete < 2000) {
    console.error('ERROR: domComplete below 2 seconds')
  }

  await browser.close()
})()

(async () => {
  const browser = await pw.chromium.connect({
    wsEndpoint: 'wss://cloud.testingbot.com/playwright?key=api_key&secret=api_secret&browserName=chrome&browserVersion=latest',
  })
  const context = await browser.newContext()
  const page = await context.newPage()

  await page.goto('https://testingbot.com/');
  const resourceTimingJson = await page.evaluate(() =>
    JSON.stringify(window.performance.getEntriesByType('resource'))
  )

  const resourceTiming = JSON.parse(resourceTimingJson)
  const logoResourceTiming = resourceTiming.find((element) =>
    element.name.includes('.webp')
  )

  console.log(logoResourceTiming)

  await browser.close()
})()

(async () => {
  const browser = await pw.chromium.connect({
    wsEndpoint: 'wss://cloud.testingbot.com/playwright?key=api_key&secret=api_secret&browserName=chrome&browserVersion=latest',
  })
  const context = await browser.newContext()
  const page = await context.newPage()

  await page.goto('https://testingbot.com/');
  const paintTimingJson = await page.evaluate(() =>
    JSON.stringify(window.performance.getEntriesByType('paint'))
  )
  const paintTiming = JSON.parse(paintTimingJson)

  console.log(paintTiming)

  await browser.close()
})()

(async () => {
  const browser = await pw.chromium.connect({
    wsEndpoint: 'wss://cloud.testingbot.com/playwright?key=api_key&secret=api_secret&browserName=chrome&browserVersion=latest',
  })
  const context = await browser.newContext()
  const page = await context.newPage()

  await page.goto('https://testingbot.com/');
  const cummulativeLayoutShift = await page.evaluate(() => {
    return new Promise((resolve) => {
      let CLS = 0

      new PerformanceObserver((l) => {
        const entries = l.getEntries()

        entries.forEach(entry => {
          if (!entry.hadRecentInput) {
            CLS += entry.value
          }
        })

        resolve(CLS)
      }).observe({
        type: 'layout-shift',
        buffered: true
      })
    })
  })

  console.log(parseFloat(cummulativeLayoutShift))

  await browser.close()
})()

(async () => {
  const browser = await pw.chromium.connect({
    wsEndpoint: 'wss://cloud.testingbot.com/playwright?key=api_key&secret=api_secret&browserName=chrome&browserVersion=latest',
  })
  const context = await browser.newContext()
  const page = await context.newPage()

  await page.goto('https://testingbot.com/');
  const totalBlockingTime = await page.evaluate(() => {
    return new Promise((resolve) => {
      let totalBlockingTime = 0
      new PerformanceObserver(function (list) {
        const perfEntries = list.getEntries()
        for (const perfEntry of perfEntries) {
          totalBlockingTime += perfEntry.duration - 50
        }
        resolve(totalBlockingTime)
      }).observe({ type: 'longtask', buffered: true })

      // Resolve promise if there haven't been any long tasks
      setTimeout(() => resolve(totalBlockingTime), 5000)
    })
  })

  console.log(parseFloat(totalBlockingTime))

  await browser.close()
})()
